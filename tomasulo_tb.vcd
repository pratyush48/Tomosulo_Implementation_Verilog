$date
	Mon May 18 20:48:47 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module tomasulo_tb $end
$var reg 1 ! clk1 $end
$var reg 1 " clk2 $end
$var reg 4 # pc [3:0] $end
$var integer 32 $ clock_cycle [31:0] $end
$var integer 32 % k [31:0] $end
$scope module tomas $end
$var wire 1 ! clk1 $end
$var wire 1 " clk2 $end
$var wire 4 & pc [3:0] $end
$var wire 16 ' inst [15:0] $end
$var reg 3 ( head_p [2:0] $end
$var reg 4 ) pr1_func [3:0] $end
$var reg 4 * pr1_rd [3:0] $end
$var reg 4 + pr1_rs1 [3:0] $end
$var reg 4 , pr1_rs2 [3:0] $end
$var reg 1 - pr2_count $end
$var reg 4 . pr2_func [3:0] $end
$var reg 4 / pr2_rd [3:0] $end
$var reg 3 0 pr2_rob_ind [2:0] $end
$var reg 4 1 pr2_rs1 [3:0] $end
$var reg 1 2 pr2_rs1b $end
$var reg 4 3 pr2_rs2 [3:0] $end
$var reg 1 4 pr2_rs2b $end
$var reg 1 5 pr3_addexec $end
$var reg 4 6 pr3_func [3:0] $end
$var reg 1 7 pr3_mulexec $end
$var reg 4 8 pr3_rd [3:0] $end
$var reg 3 9 pr3_rob_ind [2:0] $end
$var reg 8 : pr3_rs1data [7:0] $end
$var reg 8 ; pr3_rs2data [7:0] $end
$var reg 3 < pr3_rsindex [2:0] $end
$var reg 3 = tail_p [2:0] $end
$var integer 32 > add_count [31:0] $end
$var integer 32 ? bch_count [31:0] $end
$var integer 32 @ mul_count [31:0] $end
$scope module is1 $end
$var wire 1 ! clk1 $end
$var wire 1 " clk2 $end
$var wire 4 A func [3:0] $end
$var wire 4 B rd [3:0] $end
$var wire 4 C rs1 [3:0] $end
$var wire 4 D rs2 [3:0] $end
$var reg 16 E Zout [15:0] $end
$scope module rs $end
$var wire 1 ! clk1 $end
$var wire 1 " clk2 $end
$var wire 1 - count $end
$var wire 4 F func [3:0] $end
$var wire 4 G rd [3:0] $end
$var wire 3 H rob_ind [2:0] $end
$var wire 4 I rs1 [3:0] $end
$var wire 1 2 rs1_b $end
$var wire 4 J rs2 [3:0] $end
$var wire 1 4 rs2_b $end
$var reg 1 K exec_b $end
$var integer 32 L add_index [31:0] $end
$var integer 32 M mul_index [31:0] $end
$var integer 32 N temp2 [31:0] $end
$var integer 32 O temp3 [31:0] $end
$var integer 32 P temp4 [31:0] $end
$scope module ex $end
$var wire 1 ! clk1 $end
$var wire 1 " clk2 $end
$var wire 1 K exec_b $end
$var wire 4 Q func [3:0] $end
$var wire 4 R rd [3:0] $end
$var wire 3 S rob_ind [2:0] $end
$var wire 8 T rs1_data [7:0] $end
$var wire 8 U rs2_data [7:0] $end
$var wire 3 V rs_index [2:0] $end
$var reg 16 W out1 [15:0] $end
$var integer 32 X count_as [31:0] $end
$var integer 32 Y count_md [31:0] $end
$var integer 32 Z temp [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module k1 $end
$var wire 4 [ PC [3:0] $end
$var wire 1 ! clk1 $end
$var reg 16 \ output_instruction [15:0] $end
$var integer 32 ] num [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx ]
bx \
b0 [
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
xK
bx J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
b0 @
b0 ?
b0 >
b0 =
bx <
bx ;
bx :
bx 9
bx 8
07
bx 6
05
x4
bx 3
x2
bx 1
bx 0
bx /
bx .
x-
bx ,
bx +
bx *
bx )
b0 (
bx '
b0 &
b11 %
b0 $
b0 #
0"
0!
$end
#5
0K
b11 *
b11 B
b10 ,
b10 D
b1 +
b1 C
b10 )
b10 A
b10000100100011 '
b10000100100011 \
b0 ]
b11111111111111111111111111111111 P
b11 O
b11 N
1!
#10
0!
#15
b11 /
b11 G
b10 .
b10 F
b10 3
b10 J
b1 1
b1 I
b1 @
b1 =
b0 0
b0 H
14
12
1-
b1 #
b1 &
b1 [
1"
#20
b1 $
0"
#25
b101 *
b101 B
b100 ,
b100 D
b11 +
b11 C
b0 )
b0 A
b11 O
b11 N
b0 M
b11111111111111111111111111111111 P
b1101000101 '
b1101000101 \
b1 ]
1!
#30
0!
#35
b10 #
b10 &
b10 [
b101 /
b101 G
b0 .
b0 F
b100 3
b100 J
b0 1
b0 I
b1 >
b10 =
b1 0
b1 H
02
1-
1"
#40
b10 $
0"
#45
1K
b11 8
b11 R
b10 6
b10 Q
b10 ;
b10 U
b1 :
b1 T
b0 <
b0 V
b111 *
b111 B
b110 ,
b110 D
b10 +
b10 C
b1001100111 '
b1001100111 \
b10 ]
b0 L
b11111111111111111111111111111111 P
17
b0 9
b0 S
b11 O
b11 N
1!
#50
0!
#55
b0 Y
b0 X
b111 /
b111 G
b110 3
b110 J
b10 1
b10 I
b10 >
b11 =
b10 0
b10 H
12
1-
b11 #
b11 &
b11 [
1"
#60
b11 $
0"
#65
0K
b1010 *
b1010 B
b1001 ,
b1001 D
b1000 +
b1000 C
b11 O
b11 N
b1 L
b11111111111111111111111111111111 P
b100010011010 '
b100010011010 \
b11 ]
1!
#70
0!
#75
b100 #
b100 &
b100 [
b1010 /
b1010 G
b1001 3
b1001 J
b1000 1
b1000 I
b11 >
b100 =
b11 0
b11 H
1-
1"
b11 Z
07
b1 Y
b10 W
#80
b100 $
0"
#85
1K
b101 8
b101 R
b1 9
b1 S
b0 6
b0 Q
b100 ;
b100 U
b10 :
b10 T
bx *
bx B
bx ,
bx D
bx +
bx C
bx )
bx A
bx '
bx \
b100 ]
b10 L
b11111111111111111111111111111111 P
b11 O
15
b11 N
1!
#90
0!
#95
b0 Y
bx /
bx G
bx .
bx F
bx 3
bx J
bx 1
bx I
b101 =
b100 0
b100 H
1-
b101 #
b101 &
b101 [
1"
#100
b101 $
0"
#105
0K
b101 *
b101 B
b11 ,
b11 D
b101 +
b101 C
b1 )
b1 A
b11 O
b11 N
b11111111111111111111111111111111 P
b1010100110101 '
b1010100110101 \
b101 ]
1!
#110
0!
#115
b110 #
b110 &
b110 [
b101 /
b101 G
b1 .
b1 F
b11 3
b11 J
b101 1
b101 I
b100 >
b110 =
b101 0
b101 H
1-
1"
b11 Z
05
b1 X
b110 W
#120
b110 $
0"
#125
1K
b111 8
b111 R
b10 9
b10 S
b110 ;
b110 U
b1 <
b1 V
bx *
bx B
bx ,
bx D
bx +
bx C
bx )
bx A
bx '
bx \
b110 ]
b0 L
b11111111111111111111111111111111 P
b11 O
15
b11 N
1!
#130
0!
#135
b0 X
bx /
bx G
bx .
bx F
bx 3
bx J
bx 1
bx I
b111 =
b110 0
b110 H
1-
b111 #
b111 &
b111 [
1"
#140
b111 $
0"
#145
0K
b11 O
b11 N
b11111111111111111111111111111111 P
b111 ]
1!
#150
0!
#155
b1000 #
b1000 &
b1000 [
b0 =
b111 0
b111 H
1-
1"
b11 Z
05
b1 X
b1000 W
#160
b1000 $
0"
