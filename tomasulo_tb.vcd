$date
	Mon May 18 00:49:07 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module tomasulo_tb $end
$var reg 1 ! clk1 $end
$var reg 1 " clk2 $end
$var reg 4 # pc [3:0] $end
$var integer 32 $ k [31:0] $end
$scope module tomas $end
$var wire 1 ! clk1 $end
$var wire 1 " clk2 $end
$var wire 4 % pc [3:0] $end
$var wire 16 & inst [15:0] $end
$var reg 3 ' head_p [2:0] $end
$var reg 4 ( pr1_func [3:0] $end
$var reg 4 ) pr1_rd [3:0] $end
$var reg 4 * pr1_rs1 [3:0] $end
$var reg 4 + pr1_rs2 [3:0] $end
$var reg 1 , pr2_count $end
$var reg 4 - pr2_func [3:0] $end
$var reg 4 . pr2_rd [3:0] $end
$var reg 3 / pr2_rob_ind [2:0] $end
$var reg 4 0 pr2_rs1 [3:0] $end
$var reg 1 1 pr2_rs1b $end
$var reg 4 2 pr2_rs2 [3:0] $end
$var reg 1 3 pr2_rs2b $end
$var reg 1 4 pr3_addexec $end
$var reg 4 5 pr3_func [3:0] $end
$var reg 1 6 pr3_mulexec $end
$var reg 4 7 pr3_rd [3:0] $end
$var reg 3 8 pr3_rob_ind [2:0] $end
$var reg 8 9 pr3_rs1data [7:0] $end
$var reg 8 : pr3_rs2data [7:0] $end
$var reg 3 ; tail_p [2:0] $end
$var integer 32 < add_count [31:0] $end
$var integer 32 = bch_count [31:0] $end
$var integer 32 > mul_count [31:0] $end
$scope module is1 $end
$var wire 1 ! clk1 $end
$var wire 1 " clk2 $end
$var wire 4 ? func [3:0] $end
$var wire 4 @ rd [3:0] $end
$var wire 4 A rs1 [3:0] $end
$var wire 4 B rs2 [3:0] $end
$var reg 16 C Zout [15:0] $end
$var integer 32 D index [31:0] $end
$scope module rs $end
$var wire 1 ! clk1 $end
$var wire 1 " clk2 $end
$var wire 1 , count $end
$var wire 4 E func [3:0] $end
$var wire 4 F rd [3:0] $end
$var wire 3 G rob_ind [2:0] $end
$var wire 4 H rs1 [3:0] $end
$var wire 1 1 rs1_b $end
$var wire 4 I rs2 [3:0] $end
$var wire 1 3 rs2_b $end
$var reg 1 J exec_b $end
$var integer 32 K temp [31:0] $end
$var integer 32 L temp2 [31:0] $end
$scope module ex $end
$var wire 1 ! clk1 $end
$var wire 1 J exec_b $end
$var wire 4 M func [3:0] $end
$var wire 4 N rd [3:0] $end
$var wire 3 O rob_ind [2:0] $end
$var wire 8 P rs1_data [7:0] $end
$var wire 8 Q rs2_data [7:0] $end
$var reg 16 R out1 [15:0] $end
$var integer 32 S count_as [31:0] $end
$var integer 32 T count_md [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module k1 $end
$var wire 4 U PC [3:0] $end
$var wire 1 ! clk1 $end
$var reg 16 V output_instruction [15:0] $end
$var integer 32 W num [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx W
bx V
b0 U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
xJ
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
b0 >
b0 =
b0 <
b0 ;
bx :
bx 9
bx 8
bx 7
06
bx 5
04
x3
bx 2
x1
bx 0
bx /
bx .
bx -
x,
bx +
bx *
bx )
bx (
b0 '
bx &
b0 %
b1000 $
b0 #
0"
0!
$end
#5
b1 ;
b11 )
b11 @
b10 +
b10 B
b1 *
b1 A
b10 (
b10 ?
b10000100100011 &
b10000100100011 V
b0 W
b0 /
b0 G
13
11
1,
b0xxxx D
1!
#10
0!
#15
b11 L
0J
b1 #
b1 %
b1 U
1"
#20
0"
#25
b10 -
b10 E
b10 2
b10 I
b1 0
b1 H
b10 ;
b101 )
b101 @
b100 +
b100 B
b11 *
b11 A
b0 (
b0 ?
b11 .
b11 F
b1 >
b1 /
b1 G
1,
b1 D
b1101000101 &
b1101000101 V
b1 W
1!
#30
0!
#35
b10 #
b10 %
b10 U
b11 L
1"
#40
0"
#45
b0 -
b0 E
b100 2
b100 I
b11 0
b11 H
b11 ;
b111 )
b111 @
b110 +
b110 B
b10 *
b10 A
b1001100111 &
b1001100111 V
b10 W
b101 .
b101 F
b1 <
b10 /
b10 G
01
1,
b11 D
1!
#50
0!
#55
b11 L
b11 #
b11 %
b11 U
1"
#60
0"
#65
b110 2
b110 I
b10 0
b10 H
b100 ;
b1010 )
b1010 @
b1001 +
b1001 B
b1000 *
b1000 A
b111 .
b111 F
b10 <
b11 /
b11 G
11
1,
b10 D
b100010011010 &
b100010011010 V
b11 W
1!
#70
0!
#75
b100 #
b100 %
b100 U
b11 L
1"
#80
0"
#85
b1001 2
b1001 I
b1000 0
b1000 H
b101 ;
b1011 )
b1011 @
b1010 +
b1010 B
b111 *
b111 A
b10 (
b10 ?
b10011110101011 &
b10011110101011 V
b100 W
b1010 .
b1010 F
b11 <
b100 /
b100 G
1,
b1000 D
1!
#90
0!
#95
b11 L
b101 #
b101 %
b101 U
1"
#100
0"
#105
b10 -
b10 E
b1010 2
b1010 I
b111 0
b111 H
b110 ;
b101 )
b101 @
b1011 +
b1011 B
b101 *
b101 A
b1 (
b1 ?
b1011 .
b1011 F
b10 >
b101 /
b101 G
03
01
1,
b111 D
b1010110110101 &
b1010110110101 V
b101 W
1!
#110
0!
#115
b110 #
b110 %
b110 U
b11 L
1"
#120
0"
